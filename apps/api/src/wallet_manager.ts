import { turnkeyClient, ORG_ID } from "./turnkey_client";
import { Buffer } from "buffer";
import fetch from "node-fetch";
import {
    Connection,
    Keypair,
    Transaction,
    VersionedTransaction
} from "@solana/web3.js";

interface CreatePulseWalletResponse {
    subOrganizationId: string;
    walletAddress: string;
    privateKeyId: string;
}

export class WalletManager {
    connection: Connection;

    constructor() {
        const RPC_URL: string = process.env.SOLANA_RPC_URL || "https://api.devnet.solana.com";
        this.connection = new Connection(RPC_URL, {
            commitment: "confirmed",
            fetch: fetch as any
        });
    }
    /**
     * Creates a new User Sub-Organization and a Solana private key.
     * This is the "Pulse Wallet" initialization.
     * Uses the correct Turnkey v2 SDK API shape.
     */
    async createPulseWallet(userEmail: string): Promise<CreatePulseWalletResponse> {
        console.log(`Creating Pulse Wallet for ${userEmail}...`);

        // â”€â”€ 1. Create Sub-Organization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const subOrgName = `AETERNA Pulse - ${userEmail}`;
        const subOrgResult = await turnkeyClient.createSubOrganization({
            organizationId: ORG_ID as string,
            parameters: {
                subOrganizationName: subOrgName,
                rootUsers: [
                    {
                        userName: "AETERNA Admin",
                        userEmail: userEmail,
                        apiKeys: [],
                        authenticators: [],
                        oauthProviders: [],
                    },
                ],
                rootQuorumThreshold: 1,
            },
            timestampMs: Date.now().toString(),
            type: "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
        });

        // Turnkey v2: results are nested under activity.result
        const subOrgId = (subOrgResult as any).activity?.result?.createSubOrganizationResultV7?.subOrganizationId
            ?? (subOrgResult as any).subOrganizationId;

        if (!subOrgId) throw new Error("Failed to create Turnkey sub-organization");
        console.log(`Sub-Org Created: ${subOrgId}`);

        // â”€â”€ 2. Create Solana Private Key inside that Sub-Org â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const keyResult = await turnkeyClient.createPrivateKeys({
            organizationId: subOrgId,
            parameters: {
                privateKeys: [
                    {
                        privateKeyName: "Pulse Signer",
                        curve: "CURVE_ED25519",
                        privateKeyTags: [],
                        addressFormats: ["ADDRESS_FORMAT_SOLANA"],
                        // No inputFormats â€” Turnkey HSM auto-generates the key
                    }
                ]
            },
            timestampMs: Date.now().toString(),
            type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
        });

        const keys = (keyResult as any).activity?.result?.createPrivateKeysResultV2?.privateKeys
            ?? (keyResult as any).privateKeys;

        if (!keys || keys.length === 0) throw new Error("Failed to create Turnkey private key");

        const privateKeyId = keys[0].privateKeyId;
        const walletAddress = keys[0].addresses?.[0]?.address;

        if (!walletAddress) throw new Error("No Solana address generated by Turnkey");
        console.log(`Pulse Wallet Address: ${walletAddress}`);

        return { subOrganizationId: subOrgId, walletAddress, privateKeyId };
    }

    /**
     * Verify a transaction against a whitelist of allowed programs.
     * Prevents the Pulse wallet from being used to call arbitrary programs.
     */
    async verifyTransaction(unsignedTx: string): Promise<boolean> {
        try {
            const txBuffer = Buffer.from(unsignedTx, "hex");
            const tx = VersionedTransaction.deserialize(txBuffer);
            const message = tx.message;
            const accountKeys = message.staticAccountKeys;

            const ALLOWED_PROGRAMS = [
                "E3aVLq7oT4BFPjHRXaZmYupDJ9EZTG8At8oafLKzPMBG", // AETERNA Protocol
                "11111111111111111111111111111111",             // System Program
                "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcQb", // Memo
                "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",  // Token
                "CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d", // Metaplex Core
            ];

            for (const ix of message.compiledInstructions) {
                const programId = accountKeys[ix.programIdIndex].toBase58();
                if (!ALLOWED_PROGRAMS.includes(programId)) {
                    console.warn(`BLOCKED: Unauthorized program: ${programId}`);
                    return false;
                }
            }
            return true;
        } catch (e) {
            console.error("Verification Failed:", e);
            return false;
        }
    }

    /**
     * Simulates a transaction using Helius/RPC.
     */
    async simulateTransaction(unsignedTx: string): Promise<{ success: boolean; error?: string }> {
        console.log("ðŸ›¡ï¸ Simulation Sentinel: Inspecting transaction...");

        try {
            const isValid = await this.verifyTransaction(unsignedTx);
            if (!isValid) return { success: false, error: "Unauthorized Program Interaction" };

            // Real Simulation via Solana RPC
            const txBuffer = Buffer.from(unsignedTx, "hex");
            const tx = VersionedTransaction.deserialize(txBuffer);

            const simulationResult = await this.connection.simulateTransaction(tx, {
                replaceRecentBlockhash: true,
                commitment: "confirmed"
            });

            if (simulationResult.value.err) {
                console.error("Simulation Error Details:", simulationResult.value.logs);
                return { success: false, error: "On-Chain Simulation Failed: " + JSON.stringify(simulationResult.value.err) };
            }

            // Inspect Logs for malicious transfers (Drains)
            const logs = simulationResult.value.logs || [];
            if (logs.some(log => log.includes("insufficient funds") || log.includes("Custom error"))) {
                return { success: false, error: "Simulation detected malicious contract abort." };
            }

            console.log("âœ… Simulation Passed: No critical risks detected.");
            return { success: true };
        } catch (e) {
            return { success: false, error: "Simulation Failed: " + (e as Error).message };
        }
    }

    /**
     * Sign a Solana transaction using the Pulse Wallet via Turnkey.
     * Uses the correct Turnkey v2 activity type SIGN_TRANSACTION_V2.
     */
    async signTransaction(
        subOrgId: string,
        privateKeyId: string,
        unsignedTx: string
    ): Promise<string> {
        const isValid = await this.verifyTransaction(unsignedTx);
        if (!isValid) {
            throw new Error("Security Alert: Transaction blocked â€” unauthorized program interaction.");
        }

        const simulation = await this.simulateTransaction(unsignedTx);
        if (!simulation.success) {
            throw new Error(`ðŸ›‘ SECURITY BLOCK: ${simulation.error}`);
        }

        const signResult = await turnkeyClient.signTransaction({
            organizationId: subOrgId,
            parameters: {
                signWith: privateKeyId,
                unsignedTransaction: unsignedTx,
                type: "TRANSACTION_TYPE_SOLANA",
            },
            timestampMs: Date.now().toString(),
            type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
        });

        const signedTx = (signResult as any).activity?.result?.signTransactionResult?.signedTransaction
            ?? (signResult as any).signedTransaction;

        if (!signedTx) throw new Error("Failed to get signed transaction from Turnkey");
        return signedTx;
    }
}
